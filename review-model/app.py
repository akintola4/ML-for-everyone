# -*- coding: utf-8 -*-
"""reviews-test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sEHd7j_G_kBWJwjs-UijZje0skYY57F_

INSTALL DEPENDENCIES
"""
#install this
#pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118
#install this 
#pip install transformers requests beautifulsoup4 pandas numpy

"""instantiate model"""

#this is used to import the needed dpendecies
from transformers import AutoTokenizer, AutoModelForSequenceClassification
# this is used to import
import torch
# this will import torch.py
import requests
from bs4 import BeautifulSoup
import re
import pandas as pd
import numpy as np

tokenizer = AutoTokenizer.from_pretrained('nlptown/bert-base-multilingual-uncased-sentiment')

model = AutoModelForSequenceClassification.from_pretrained('nlptown/bert-base-multilingual-uncased-sentiment')

tokens = tokenizer.encode('i hate the product', return_tensors='pt')
#this method will encode a text into int

#tokens[0]
#we can print it out
#remember to select the first data in the list
# and we can also decode the encoded string
#tokenizer.decode(tokens[0])

result = model(tokens)
#this is to test the token for the sentiment using our model

result
#this is to print out the result of the model with is on a one encoded list
#the position with the highest score represent the sentiment

result.logits
#this is to  will print out the entire tensor result

torch.argmax(result.logits)
#this is used to get the highest value in our result and gives us our rating

r = requests.get('https://www.yelp.com/biz/social-brew-cafe-pyrmont')
#this will request for the data in the website
soup = BeautifulSoup(r.text, 'html.parser')
#this allows is to create
regex = re.compile('.*comment.*')
#this to specify what class name we looking for in the html code
results = soup.find_all('p', {'class':regex})
# hete we aree looking for any tag with a p tag
#then we also looking for one with the class of the regex we stated
reviews = [result.text for result in results]
#this is used to loop through the data in results for the text in the p tag so
#we only collect the data (text) in the tag

reviews

df = pd.DataFrame(np.array(reviews), columns=['review'])
#we import our data into a data frame
df

df['review'].iloc[0]

def sentiment_score(review):
  tokens = tokenizer.encode(review, return_tensors='pt')
  result = model(tokens)
  return int(torch.argmax(result.logits))+1
## here we craeted a function to test for the sentiment of the data given above
# most steps here were created from the code above on how to use our model to test for sentiment

sentiment_score(df['review'].iloc[0])
#this will test and then return the output of the test

df['sentiment'] = df['review'].apply(lambda x: sentiment_score(x[:512]))
#this will allows us test for the entire dataset
#df['review'] it helps us to extract our reviews column
#.apply(lambda this allows us to loop through the review dataset
#nlp terminal is limited and can allow [:512] for a time
# allows it addes the sentiment score to the review table

df
#this will print out the new table

from matplotlib import pyplot as plt
df['sentiment'].plot(kind='hist', bins=20, title='sentiment')
plt.gca().spines[['top', 'right',]].set_visible(False)
#this will show us a grap of the results